#!/usr/bin/env python3

# quick-lint-js finds bugs in JavaScript programs.
# Copyright (C) 2020  Matthew Glazar
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Generate quick-lint-js copyright documentation.

Run this program to generate a text file listing copyrights and licenses for
software used by quick-lint-js (and quick-lint-js' own copyright and license).
"""

import argparse
import os
import pathlib
import re
import subprocess
import sys
import typing
import unittest

archive_to_vendor_project = {
    "libboost_container.a": "boost",
    "libquick-lint-js-lib.a": None,
    "libsimdjson.a": "simdjson",
}


def main() -> None:
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument(
        "--elf-linkmap",
        required=True,
        help="File generated by an ELF linker's -Map option",
    )
    parser.add_argument(
        "--vendor-readme",
        required=False,
        default=str(pathlib.Path(__file__).parent / ".." / "vendor" / "README.txt"),
    )
    args = parser.parse_args()

    qljs_license_text = (pathlib.Path(__file__).parent / ".." / "COPYING").read_text()
    print(
        f"""\
# quick-lint-js licenses

The quick-lint-js program is Copyright (C) 2020 Matthew Glazar. It is
distributed under the following license:
{markdown_block_quote(qljs_license_text)}

Parts of quick-lint-js might be distributed under different licenses:
"""
    )

    vendor_readme_file = pathlib.Path(args.vendor_readme)
    vendor_projects = parse_vendor_readme_txt(vendor_readme_file.read_text())

    dump_from_linkmap(
        link_map_file=pathlib.Path(args.elf_linkmap),
        vendor_projects=vendor_projects,
        vendor_directory=vendor_readme_file.parent,
    )


def dump_from_linkmap(
    link_map_file: pathlib.Path,
    vendor_projects: typing.List["VendorReadmeProject"],
    vendor_directory: pathlib.Path,
) -> None:
    link_map = parse_link_map(link_map_file.read_text())
    linked_system_archives = [
        file for file in link_map.linked_archives if pathlib.Path(file).is_absolute()
    ]
    linked_vendored_archives = [
        file
        for file in link_map.linked_archives
        if not pathlib.Path(file).is_absolute()
    ]
    dump_from_vendor(
        linked_vendored_archives,
        vendor_projects=vendor_projects,
        vendor_directory=vendor_directory,
    )
    dump_from_system_archives(linked_system_archives)


def dump_from_vendor(
    archives: typing.List[str],
    vendor_projects: typing.List["VendorReadmeProject"],
    vendor_directory: pathlib.Path,
) -> None:
    for archive in sorted(archives):
        try:
            vendor_project_name = archive_to_vendor_project[pathlib.Path(archive).name]
        except KeyError:
            raise Exception(f"could not find source for archive: {archive}") from None
        if vendor_project_name is None:
            # Archive is quick-lint-js itself. Its license is handled elsewhere.
            continue

        matching_vendor_projects = [
            p for p in vendor_projects if p.project_name == vendor_project_name
        ]
        if len(matching_vendor_projects) != 1:
            raise Exception(
                f"could not find vendor project for archive: {archive} (project name: {vendor_project_name}"
            ) from None
        vendor_project = matching_vendor_projects[0]

        license_files = vendor_project.properties["License file"].split("; ")
        license = (vendor_directory / license_files[0]).read_text()

        print(
            f"""\
## {vendor_project_name}

Version {vendor_project.properties['Version']} of {vendor_project_name} is statically linked into quick-lint-js.

Source code for {vendor_project_name} is available at:
* {vendor_project.properties['Download URL']}

Copyright information for libc6-dev:amd64:
{markdown_block_quote(license)})
"""
        )


def detect_system_package_manager():
    if os.environ.get("NIX_STORE", ""):
        warn("Nix not well supported")
        return Nix()

    try:
        subprocess.check_output(["rpm", "--query", "glibc"])
        return RedHat()
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass

    try:
        subprocess.check_output(["dpkg-query", "--list", "libc6"])
        return Debian()
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass

    raise Exception("Could not detect system package manager")


def dump_from_system_archives(linked_system_archives: typing.List[str]) -> None:
    if not linked_system_archives:
        return

    system_package_manager = detect_system_package_manager()
    installed_packages = system_package_manager.packages_for_installed_files(
        linked_system_archives
    )
    source_package_names = set(p.source for p in installed_packages)

    for source_package_name in sorted(source_package_names):
        print(f"## {source_package_name}\n")

        relevant_installed_packages = [
            p for p in sorted(installed_packages) if p.source == source_package_name
        ]

        for p in relevant_installed_packages:
            print(
                f"Version {p.version} of package {p.name} is statically linked into quick-lint-js.\n"
            )

        print(f"Source code for {source_package_name} is available at:")
        source_uris = []
        for p in relevant_installed_packages:
            source_uris.extend(p.source_uris)
        if source_uris:
            for source_uri in sorted(set(source_uris)):
                print(f"* {source_uri}")
        else:
            print(f"* (location unknown!)")

        for p in relevant_installed_packages:
            print(f"\nCopyright information for {p.name}:")
            copyright = system_package_manager.get_copyright(p)
            print(markdown_block_quote(copyright))

        print(f"")


def markdown_block_quote(text: str) -> str:
    return "> " + text.strip("\n").replace("\n", "\n> ")


class Debian:
    class InstalledPackage(typing.NamedTuple):
        name: str
        source: str
        version: str
        source_uris: typing.Tuple[str, ...]

    def packages_for_installed_files(
        self, files: typing.Iterable[str]
    ) -> typing.List[InstalledPackage]:
        package_names = self._dpkg_packages_for_installed_files(files)
        packages = self._get_installed_debian_packages(set(package_names))
        packages = [
            p._replace(
                source_uris=tuple(
                    self._get_package_apt_source_uri(name=p.source, version=p.version)
                )
            )
            for p in packages
        ]
        return packages

    def get_copyright(self, package: InstalledPackage) -> str:
        package_name = package.name.split(":")[0]  # HACK: Strip architecture.
        return (pathlib.Path("/usr/share/doc") / package_name / "copyright").read_text()

    @staticmethod
    def _dpkg_packages_for_installed_files(
        files: typing.Iterable[str],
    ) -> typing.List[str]:
        process = subprocess.run(
            ["dpkg-query", "--search", "--"] + list(files),
            stdout=subprocess.PIPE,
            encoding="utf-8",
        )
        process.check_returncode()

        packages = []
        for line in process.stdout.splitlines():
            match = re.match(f"^(?P<package>\S+): (?P<file>.*)$", line)
            if match is not None:
                packages.append(match.group("package"))
        return packages

    @classmethod
    def _get_installed_debian_packages(
        cls,
        package_names: typing.Iterable[str],
    ) -> typing.List[InstalledPackage]:
        process = subprocess.run(
            [
                "dpkg-query",
                "--show",
                "--showformat=${binary:Package}\\t${Source}\\t${Version}\\t${db:Status-Status}\\n",
                "--",
            ]
            + list(package_names),
            stdout=subprocess.PIPE,
            encoding="utf-8",
        )
        process.check_returncode()

        packages = []
        for line in process.stdout.splitlines():
            parts = line.split("\t")
            if parts[3] == "installed":
                packages.append(
                    cls.InstalledPackage(
                        name=parts[0], source=parts[1], version=parts[2], source_uris=()
                    )
                )
        return packages

    @classmethod
    def _get_package_apt_source_uri(cls, name: str, version: str) -> typing.List[str]:
        process = subprocess.run(
            ["apt-get", "source", "--print-uris", "-qq", "--", f"{name}={version}"],
            stdout=subprocess.PIPE,
            encoding="utf-8",
        )
        if process.returncode == 100:
            warn(f"failed to get source URIs for package {name}")
            return []
        process.check_returncode()
        return cls._parse_apt_get_source_uris(process.stdout)

    @staticmethod
    def _parse_apt_get_source_uris(raw: str) -> typing.List[str]:
        source_uris = []
        for line in raw.splitlines():
            match = re.match(r"^'(?P<uri>.*)' .*$", line)
            if match is not None:
                source_uris.append(match.group("uri"))
        return source_uris


class Nix:
    def packages_for_installed_files(
        self, files: typing.Iterable[str]
    ) -> typing.List[None]:
        # TODO(strager)
        return []


class RedHat:
    class InstalledPackage(typing.NamedTuple):
        name: str
        source: str
        version: str
        source_uris: typing.Tuple[str, ...]

    def packages_for_installed_files(
        self, files: typing.Iterable[str]
    ) -> typing.List[InstalledPackage]:
        package_names = [self._rpm_package_for_installed_file(f) for f in files]
        packages = [self._get_rpm_package(name) for name in set(package_names)]
        return packages

    def get_copyright(self, package: InstalledPackage) -> str:
        raw_text = (
            pathlib.Path("/usr/share/licenses") / package.source / "LICENSES"
        ).read_text()
        return raw_text.replace("\x0C", "\n---\n")

    @staticmethod
    def _rpm_package_for_installed_file(file_path: str) -> str:
        process = subprocess.run(
            ["rpm", "--query", "--whatprovides", "--", file_path],
            stdout=subprocess.PIPE,
            encoding="utf-8",
        )
        process.check_returncode()
        return process.stdout.rstrip("\n")

    @classmethod
    def _get_rpm_package(cls, package_name: str) -> InstalledPackage:
        source_rpm_info = subprocess.check_output(
            [
                "dnf",
                "--quiet",
                "repoquery",
                "--qf",
                "%{name}\\t%{version}-%{release}\\t%{source_name}",
                "--",
                package_name,
            ],
            encoding="utf-8",
        ).rstrip("\n")
        [name, version, source_name] = source_rpm_info.split("\t")
        source_rpm_url = subprocess.check_output(
            ["dnf", "--quiet", "repoquery", "--srpm", "--location", "--", package_name],
            encoding="utf-8",
        ).rstrip("\n")
        return cls.InstalledPackage(
            name=name,
            version=version,
            source=source_name,
            source_uris=(source_rpm_url,),
        )


class LinkMap(typing.NamedTuple):
    linked_archives: typing.Set[str]


def parse_link_map(raw_link_map: str) -> LinkMap:
    linked_archives = set()
    state = "NONE"
    for line in raw_link_map.splitlines():
        if line == "":
            if state == "BEFORE_ARCHIVE_MEMBERS":
                state = "ARCHIVE_MEMBERS"
            else:
                state = "NONE"
        elif line in (
            "Archive member included to satisfy reference by file (symbol)",
            "Archive member included because of file (symbol)",
        ):
            state = "BEFORE_ARCHIVE_MEMBERS"
        else:
            if state == "ARCHIVE_MEMBERS":
                match = re.match(r"^(?P<file>\S.*)\((?P<symbol>.*)\)$", line)
                if match is not None:
                    linked_archives.add(match.group("file"))
    return LinkMap(linked_archives=linked_archives)


class VendorReadmeProject(typing.NamedTuple):
    project_name: str
    properties: typing.Dict[str, str]


def parse_vendor_readme_txt(txt: str) -> typing.List[VendorReadmeProject]:
    """Parse the README.txt file in quick-lint-js' vendor/ directory."""
    projects = []
    for line in txt.splitlines():
        match = re.match(r"^## (?P<project_name>.+)$", line)
        if match is not None:
            projects.append(
                VendorReadmeProject(
                    project_name=match.group("project_name"), properties={}
                )
            )
        match = re.match(r"^(?P<key>[^:]+): (?P<value>.*)$", line)
        if match is not None and projects:
            projects[-1].properties[match.group("key")] = match.group("value")
    return projects


def warn(message: str) -> None:
    if os.environ.get("QLJS_COLLECT_COPYRIGHT_NO_WARNINGS", ""):
        print(f"{__file__}: fatal: {message}", file=sys.stderr)
        exit(1)
    print(f"{__file__}: warning: {message}", file=sys.stderr)


class TestGNULinkMap(unittest.TestCase):
    def test_small_link_map_from_bfd_ld(self) -> None:
        raw_link_map = """\
Archive member included to satisfy reference by file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o (__libc_csu_init)

Merging program properties


As-needed library included to satisfy reference by file (symbol)

libc.so.6                     /tmp/cchQcqEp.o (puts@@GLIBC_2.2.5)
"""
        link_map = parse_link_map(raw_link_map)
        self.assertEqual(
            link_map.linked_archives, {"/usr/lib/x86_64-linux-gnu/libc_nonshared.a"}
        )

    def test_small_link_map_from_gold(self) -> None:
        raw_link_map = """\
Archive member included because of file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o (__libc_csu_init)

Discarded input sections

 .note.GNU-stack
                0x0000000000000000        0x0 /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o
 .note.GNU-stack
~/P/quicklint-js> cat linkmap
Archive member included because of file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o (__libc_csu_init)

Discarded input sections

 .note.GNU-stack
                0x0000000000000000        0x0 /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o
"""
        link_map = parse_link_map(raw_link_map)
        self.assertEqual(
            link_map.linked_archives, {"/usr/lib/x86_64-linux-gnu/libc_nonshared.a"}
        )


class TestAptGetSourceURIs(unittest.TestCase):
    def test_libc6_dev(self) -> None:
        output = """\
Reading package lists... Done
Picking 'glibc' as source package instead of 'libc6-dev'
NOTICE: 'glibc' packaging is maintained in the 'Git' version control system at:
https://git.launchpad.net/~ubuntu-core-dev/ubuntu/+source/glibc
Please use:
git clone https://git.launchpad.net/~ubuntu-core-dev/ubuntu/+source/glibc
to retrieve the latest (possibly unreleased) updates to the package.
Need to get 18.2 MB of source archives.
'http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.dsc' glibc_2.31-0ubuntu9.1.dsc 9456 SHA512:b3f10b8c8f421431c91f14efbc92fc165675d5cdb427629e67d5e19927de0f4024c736c9da1c5d4b7e2bd0aa01395b3e269aeccee161918311f2ea1c75815f1f
'http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31.orig.tar.xz' glibc_2.31.orig.tar.xz 17317924 SHA512:2ff56628fe935cacbdf1825534f15d45cb87a159cbdb2e6a981590eeb6174ed4b3ff7041519cdecbd4f624ac20b745e2dd9614c420dd3ea186b8f36bc4c2453c
'http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.debian.tar.xz' glibc_2.31-0ubuntu9.1.debian.tar.xz 844816 SHA512:bca1857b031eda2d170256b97829c6b8a38493c66858a041e6f0143bf26c376c207e72d499ef1be07a83667419d55284407bae518511a702171eac58c6f31d62
"""
        source_uris = Debian._parse_apt_get_source_uris(output)
        self.assertEqual(
            source_uris,
            [
                "http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.dsc",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31.orig.tar.xz",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.debian.tar.xz",
            ],
        )

    def test_gcc_9_qq(self) -> None:
        output = """\
'http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.dsc' gcc-9_9.3.0-17ubuntu1~20.04.dsc 23746 SHA512:bae6c156516a4988546a4518934f661a70243a89ed17883fe382bd984ae6533aab7d9b459986c2ebdb715b64b11ac76b9283447b26be3dbaec0b00c02afeb7f6
'http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0.orig.tar.gz' gcc-9_9.3.0.orig.tar.gz 90490748 SHA512:cebaa27b0ac7485e72f0d7b07e6ef08cd544bf551bc080ee00175cbe319ea8b0592ff54d55633bb189e481f9ba489d513205cf2310e4b5211869a021432ee31f
'http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.debian.tar.xz' gcc-9_9.3.0-17ubuntu1~20.04.debian.tar.xz 763792 SHA512:f696a3d92edbadb7cfb29494b68ec00fa9b278ab7657e45933cf2e7564e6a524ac41edde14449114a2e06ad0c1f56473d998687aeb2f98f18c431727d4254d21
"""
        source_uris = Debian._parse_apt_get_source_uris(output)
        self.assertEqual(
            source_uris,
            [
                "http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.dsc",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0.orig.tar.gz",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.debian.tar.xz",
            ],
        )


class TestParseVendorReadme(unittest.TestCase):
    def test_parse_snippet(self) -> None:
        readme_txt = """\n
# Vendor

This vendor directory contains third-party software.

## benchmark

The benchmark directory contains Google Benchmark, a performance measurement
framework for C++ code.

Copyright: Copyright 2015 Google Inc. All rights reserved.
Version: v1.5.1

## boost

The boost directory contains Boost, free peer-reviewed portable C++ source
libraries.

Many directories and files have been deleted to reduce storage consumption.

Download URL: https://dl.bintray.com/boostorg/release/1.74.0/source/boost_1_74_0.tar.bz2
Download date: August 25, 2020
Version: 1.74.0
"""
        projects = parse_vendor_readme_txt(readme_txt)
        self.assertEqual(
            projects,
            [
                VendorReadmeProject(
                    project_name="benchmark",
                    properties={
                        "Copyright": "Copyright 2015 Google Inc. All rights reserved.",
                        "Version": "v1.5.1",
                    },
                ),
                VendorReadmeProject(
                    project_name="boost",
                    properties={
                        "Download URL": "https://dl.bintray.com/boostorg/release/1.74.0/source/boost_1_74_0.tar.bz2",
                        "Download date": "August 25, 2020",
                        "Version": "1.74.0",
                    },
                ),
            ],
        )


if __name__ == "__main__":
    main()
