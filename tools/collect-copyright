#!/usr/bin/env python3

# quick-lint-js finds bugs in JavaScript programs.
# Copyright (C) 2020  Matthew Glazar
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Generate quick-lint-js copyright documentation.

Run this program to generate a text file listing copyrights and licenses for
software used by quick-lint-js (and quick-lint-js' own copyright and license).
"""

import argparse
import pathlib
import re
import subprocess
import typing
import unittest

archive_to_vendor_project = {
    "src/libquick-lint-js-lib.a": None,
    "vendor/boost/libs/container/libboost_container.a": "boost",
    "vendor/simdjson/src/libsimdjson.a": "simdjson",
}


def main() -> None:
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument(
        "--elf-linkmap",
        required=True,
        help="File generated by an ELF linker's -Map option",
    )
    parser.add_argument(
        "--vendor-readme",
        required=False,
        default=str(pathlib.Path(__file__).parent / ".." / "vendor" / "README.txt"),
    )
    args = parser.parse_args()

    qljs_license_text = (pathlib.Path(__file__).parent / ".." / "COPYING").read_text()
    print(
        f"""\
# quick-lint-js licenses

The quick-lint-js program is Copyright (C) 2020 Matthew Glazar. It is
distributed under the following license:
{markdown_block_quote(qljs_license_text)}

Parts of quick-lint-js might be distributed under different licenses:
"""
    )

    vendor_readme_file = pathlib.Path(args.vendor_readme)
    vendor_projects = parse_vendor_readme_txt(vendor_readme_file.read_text())

    dump_from_linkmap(
        link_map_file=pathlib.Path(args.elf_linkmap),
        vendor_projects=vendor_projects,
        vendor_directory=vendor_readme_file.parent,
    )


def dump_from_linkmap(
    link_map_file: pathlib.Path,
    vendor_projects: typing.List["VendorReadmeProject"],
    vendor_directory: pathlib.Path,
) -> None:
    link_map = parse_link_map(link_map_file.read_text())
    linked_system_archives = [
        file for file in link_map.linked_archives if pathlib.Path(file).is_absolute()
    ]
    linked_vendored_archives = [
        file
        for file in link_map.linked_archives
        if not pathlib.Path(file).is_absolute()
    ]
    dump_from_vendor(
        linked_vendored_archives,
        vendor_projects=vendor_projects,
        vendor_directory=vendor_directory,
    )
    dump_from_system_archives(linked_system_archives)


def dump_from_vendor(
    archives: typing.List[str],
    vendor_projects: typing.List["VendorReadmeProject"],
    vendor_directory: pathlib.Path,
) -> None:
    for archive in sorted(archives):
        try:
            vendor_project_name = archive_to_vendor_project[archive]
        except KeyError:
            raise Exception(f"could not find source for archive: {archive}") from None
        if vendor_project_name is None:
            # Archive is quick-lint-js itself. Its license is handled elsewhere.
            continue

        matching_vendor_projects = [
            p for p in vendor_projects if p.project_name == vendor_project_name
        ]
        if len(matching_vendor_projects) != 1:
            raise Exception(
                f"could not find vendor project for archive: {archive} (project name: {vendor_project_name}"
            ) from None
        vendor_project = matching_vendor_projects[0]

        license_files = vendor_project.properties["License file"].split("; ")
        license = (vendor_directory / license_files[0]).read_text()

        print(
            f"""\
## {vendor_project_name}

Version {vendor_project.properties['Version']} of {vendor_project_name} is statically linked into quick-lint-js.

Source code for {vendor_project_name} is available at:
* {vendor_project.properties['Download URL']}

Copyright information for libc6-dev:amd64:
{markdown_block_quote(license)})
"""
        )


def dump_from_system_archives(linked_system_archives: typing.List[str]) -> None:
    package_names = set(dpkg_packages_for_installed_files(linked_system_archives))
    installed_packages = get_installed_debian_packages(package_names)
    source_package_names = set(p.source for p in installed_packages)

    for source_package_name in sorted(source_package_names):
        print(f"## {source_package_name}\n")

        for installed_package in sorted(installed_packages):
            if installed_package.source == source_package_name:
                print(
                    f"Version {installed_package.version} of package {installed_package.name} is statically linked into quick-lint-js.\n"
                )

        print(f"Source code for {source_package_name} is available at:")
        source_uris = get_package_apt_source_uri(
            name=installed_package.name, version=installed_package.version
        )
        for source_uri in sorted(source_uris):
            print(f"* {source_uri.uri}")

        for installed_package in sorted(installed_packages):
            if installed_package.source == source_package_name:
                print(f"\nCopyright information for {installed_package.name}:")
                copyright = get_dpkg_copyright(installed_package.name)
                print(markdown_block_quote(copyright))

        print(f"")


def markdown_block_quote(text: str) -> str:
    return "> " + text.strip("\n").replace("\n", "\n> ")


def get_dpkg_copyright(package_name: str) -> str:
    package_name = package_name.split(":")[0]  # HACK: Strip architecture.
    return (pathlib.Path("/usr/share/doc") / package_name / "copyright").read_text()


def dpkg_packages_for_installed_files(
    files: typing.Iterable[str],
) -> typing.Sequence[str]:
    process = subprocess.run(
        ["dpkg-query", "--search", "--no-pager", "--"] + list(files),
        stdout=subprocess.PIPE,
        encoding="utf-8",
    )
    process.check_returncode()

    packages = []
    for line in process.stdout.splitlines():
        match = re.match(f"^(?P<package>\S+): (?P<file>.*)$", line)
        if match is not None:
            packages.append(match.group("package"))
    return packages


class LinkMap(typing.NamedTuple):
    linked_archives: typing.Set[str]


def parse_link_map(raw_link_map: str) -> LinkMap:
    linked_archives = set()
    state = "NONE"
    for line in raw_link_map.splitlines():
        if line == "":
            if state == "BEFORE_ARCHIVE_MEMBERS":
                state = "ARCHIVE_MEMBERS"
            else:
                state = "NONE"
        elif line in (
            "Archive member included to satisfy reference by file (symbol)",
            "Archive member included because of file (symbol)",
        ):
            state = "BEFORE_ARCHIVE_MEMBERS"
        else:
            if state == "ARCHIVE_MEMBERS":
                match = re.match(r"^(?P<file>\S.*)\((?P<symbol>.*)\)$", line)
                if match is not None:
                    linked_archives.add(match.group("file"))
    return LinkMap(linked_archives=linked_archives)


class InstalledDebianPackage(typing.NamedTuple):
    name: str
    source: str
    version: str


def get_installed_debian_packages(
    package_names: typing.Iterable[str],
) -> typing.List[InstalledDebianPackage]:
    process = subprocess.run(
        [
            "dpkg-query",
            "--show",
            "--showformat=${binary:Package}\\t${Source}\\t${Version}\\t${db:Status-Status}\\n",
            "--",
        ]
        + list(package_names),
        stdout=subprocess.PIPE,
        encoding="utf-8",
    )
    process.check_returncode()

    packages = []
    for line in process.stdout.splitlines():
        parts = line.split("\t")
        if parts[3] == "installed":
            packages.append(
                InstalledDebianPackage(name=parts[0], source=parts[1], version=parts[2])
            )
    return packages


class AptSourceURI(typing.NamedTuple):
    uri: str


def parse_apt_get_source_uris(raw: str) -> typing.List[AptSourceURI]:
    source_uris = []
    for line in raw.splitlines():
        match = re.match(r"^'(?P<uri>.*)' .*$", line)
        if match is not None:
            source_uris.append(AptSourceURI(uri=match.group("uri")))
    return source_uris


def get_package_apt_source_uri(name: str, version: str) -> typing.List[AptSourceURI]:
    process = subprocess.run(
        ["apt-get", "source", "--print-uris", "-qq", "--", f"{name}={version}"],
        stdout=subprocess.PIPE,
        encoding="utf-8",
    )
    process.check_returncode()
    return parse_apt_get_source_uris(process.stdout)


class VendorReadmeProject(typing.NamedTuple):
    project_name: str
    properties: typing.Dict[str, str]


def parse_vendor_readme_txt(txt: str) -> typing.List[VendorReadmeProject]:
    """Parse the README.txt file in quick-lint-js' vendor/ directory."""
    projects = []
    for line in txt.splitlines():
        match = re.match(r"^## (?P<project_name>.+)$", line)
        if match is not None:
            projects.append(
                VendorReadmeProject(
                    project_name=match.group("project_name"), properties={}
                )
            )
        match = re.match(r"^(?P<key>[^:]+): (?P<value>.*)$", line)
        if match is not None and projects:
            projects[-1].properties[match.group("key")] = match.group("value")
    return projects


class TestGNULinkMap(unittest.TestCase):
    def test_small_link_map_from_bfd_ld(self) -> None:
        raw_link_map = """\
Archive member included to satisfy reference by file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o (__libc_csu_init)

Merging program properties


As-needed library included to satisfy reference by file (symbol)

libc.so.6                     /tmp/cchQcqEp.o (puts@@GLIBC_2.2.5)
"""
        link_map = parse_link_map(raw_link_map)
        self.assertEqual(
            link_map.linked_archives, {"/usr/lib/x86_64-linux-gnu/libc_nonshared.a"}
        )

    def test_small_link_map_from_gold(self) -> None:
        raw_link_map = """\
Archive member included because of file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o (__libc_csu_init)

Discarded input sections

 .note.GNU-stack
                0x0000000000000000        0x0 /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o
 .note.GNU-stack
~/P/quicklint-js> cat linkmap
Archive member included because of file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o (__libc_csu_init)

Discarded input sections

 .note.GNU-stack
                0x0000000000000000        0x0 /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o
"""
        link_map = parse_link_map(raw_link_map)
        self.assertEqual(
            link_map.linked_archives, {"/usr/lib/x86_64-linux-gnu/libc_nonshared.a"}
        )


class TestAptGetSourceURIs(unittest.TestCase):
    def test_libc6_dev(self) -> None:
        output = """\
Reading package lists... Done
Picking 'glibc' as source package instead of 'libc6-dev'
NOTICE: 'glibc' packaging is maintained in the 'Git' version control system at:
https://git.launchpad.net/~ubuntu-core-dev/ubuntu/+source/glibc
Please use:
git clone https://git.launchpad.net/~ubuntu-core-dev/ubuntu/+source/glibc
to retrieve the latest (possibly unreleased) updates to the package.
Need to get 18.2 MB of source archives.
'http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.dsc' glibc_2.31-0ubuntu9.1.dsc 9456 SHA512:b3f10b8c8f421431c91f14efbc92fc165675d5cdb427629e67d5e19927de0f4024c736c9da1c5d4b7e2bd0aa01395b3e269aeccee161918311f2ea1c75815f1f
'http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31.orig.tar.xz' glibc_2.31.orig.tar.xz 17317924 SHA512:2ff56628fe935cacbdf1825534f15d45cb87a159cbdb2e6a981590eeb6174ed4b3ff7041519cdecbd4f624ac20b745e2dd9614c420dd3ea186b8f36bc4c2453c
'http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.debian.tar.xz' glibc_2.31-0ubuntu9.1.debian.tar.xz 844816 SHA512:bca1857b031eda2d170256b97829c6b8a38493c66858a041e6f0143bf26c376c207e72d499ef1be07a83667419d55284407bae518511a702171eac58c6f31d62
"""
        source_uris = parse_apt_get_source_uris(output)
        self.assertEqual(
            [source_uri.uri for source_uri in source_uris],
            [
                "http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.dsc",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31.orig.tar.xz",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/glibc_2.31-0ubuntu9.1.debian.tar.xz",
            ],
        )

    def test_gcc_9_qq(self) -> None:
        output = """\
'http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.dsc' gcc-9_9.3.0-17ubuntu1~20.04.dsc 23746 SHA512:bae6c156516a4988546a4518934f661a70243a89ed17883fe382bd984ae6533aab7d9b459986c2ebdb715b64b11ac76b9283447b26be3dbaec0b00c02afeb7f6
'http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0.orig.tar.gz' gcc-9_9.3.0.orig.tar.gz 90490748 SHA512:cebaa27b0ac7485e72f0d7b07e6ef08cd544bf551bc080ee00175cbe319ea8b0592ff54d55633bb189e481f9ba489d513205cf2310e4b5211869a021432ee31f
'http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.debian.tar.xz' gcc-9_9.3.0-17ubuntu1~20.04.debian.tar.xz 763792 SHA512:f696a3d92edbadb7cfb29494b68ec00fa9b278ab7657e45933cf2e7564e6a524ac41edde14449114a2e06ad0c1f56473d998687aeb2f98f18c431727d4254d21
"""
        source_uris = parse_apt_get_source_uris(output)
        self.assertEqual(
            [source_uri.uri for source_uri in source_uris],
            [
                "http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.dsc",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0.orig.tar.gz",
                "http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-9/gcc-9_9.3.0-17ubuntu1~20.04.debian.tar.xz",
            ],
        )


class TestParseVendorReadme(unittest.TestCase):
    def test_parse_snippet(self) -> None:
        readme_txt = """\n
# Vendor

This vendor directory contains third-party software.

## benchmark

The benchmark directory contains Google Benchmark, a performance measurement
framework for C++ code.

Copyright: Copyright 2015 Google Inc. All rights reserved.
Version: v1.5.1

## boost

The boost directory contains Boost, free peer-reviewed portable C++ source
libraries.

Many directories and files have been deleted to reduce storage consumption.

Download URL: https://dl.bintray.com/boostorg/release/1.74.0/source/boost_1_74_0.tar.bz2
Download date: August 25, 2020
Version: 1.74.0
"""
        projects = parse_vendor_readme_txt(readme_txt)
        self.assertEqual(
            projects,
            [
                VendorReadmeProject(
                    project_name="benchmark",
                    properties={
                        "Copyright": "Copyright 2015 Google Inc. All rights reserved.",
                        "Version": "v1.5.1",
                    },
                ),
                VendorReadmeProject(
                    project_name="boost",
                    properties={
                        "Download URL": "https://dl.bintray.com/boostorg/release/1.74.0/source/boost_1_74_0.tar.bz2",
                        "Download date": "August 25, 2020",
                        "Version": "1.74.0",
                    },
                ),
            ],
        )


if __name__ == "__main__":
    main()
